from pathlib import Path
import rich
from rich.syntax import Syntax
from math import ceil
from multiprocessing import cpu_count
import gmsh

from ...helper.experiment import ExperimentConfig

console = rich.get_console()
print = console.print


DIE_PIXEL_SIZE = 8.434786e-3  # mm/pixel # 8.434786 um/pixel
DIE_RADIUS = 2.550608716  # mm # 2550.608716 um, 5_000 / (8.434786 * 2) + 6 pixels
DIE_HEIGHT = 8.51913386  # mm # 8519.13386 um, 1010 pixels
DIE_CENTER = [2.65695759, 2.65695759, 0]  # [2656.95759, 2656.95759, 0] um, 315, 315, 0 pixels


def set_diagnostic_options(experiment: ExperimentConfig, save_forces: int, save_strain_energy: int, save_swarm: int, save_solution: int,
                           save_diagnostics: int, save: bool) -> None:
    """
    Set diagnostic options for the experiment.

    :param experiment: The experiment configuration object.
    :param save_forces: Whether to save forces.
    :param save_swarm: Whether to save swarm data.
    :param save_solution: Whether to save solution data.
    :param save_diagnostics: Whether to save diagnostics.
    :param save_all: Whether to save all data.
    """
    if not save:
        return
    if save_forces > 0:
        experiment.diagnostic_options["ts_monitor_surface_force_per_face"] = "ascii:forces.csv"
        experiment.diagnostic_options["ts_monitor_surface_force_per_face_interval"] = f"{save_forces}"
    if save_strain_energy > 0:
        experiment.diagnostic_options["ts_monitor_strain_energy"] = "ascii:strain_energy.csv"
        experiment.diagnostic_options["ts_monitor_strain_energy_interval"] = f"{save_strain_energy}"
    if save_swarm > 0:
        experiment.diagnostic_options["ts_monitor_swarm_solution"] = "ascii:swarm.xmf"
        experiment.diagnostic_options["ts_monitor_swarm_fields"] = "J,volume,rho,material"
        experiment.diagnostic_options["ts_monitor_swarm_solution_interval"] = f"{save_swarm}"
    if save_solution > 0:
        experiment.diagnostic_options["ts_monitor_solution"] = r"cgns:solution_%06d.cgns"
        experiment.diagnostic_options["ts_monitor_solution_interval"] = f"{save_solution}"
    if save_diagnostics > 0:
        experiment.diagnostic_options["ts_monitor_output_fields"] = r"cgns:output_fields_%06d.cgns"
        experiment.diagnostic_options["ts_monitor_output_fields_interval"] = f"{save_diagnostics}"


def get_mesh(characteristic_length: float, voxel_data: Path,
             scratch_dir: Path, load_fraction=0.4, clamp_top=True) -> str:
    """
    Get a mesh file for the given voxel data and characteristic length, generating if necessary.

    :param characteristic_length: The desired characteristic length for the mesh.
    :param voxel_data: Path to the voxel data file (e.g., CT scan).
    :param scratch_dir: Directory to store the generated mesh file.
    :param load_fraction: Fraction of the load to apply to the die (default is 0.4).
    :param clamp_top: Whether to clamp the top of the die (default is True).

    :return: A dictionary of mesh options for the experiment configuration.
    """
    mesh_file: Path = generate_mesh(characteristic_length, voxel_data, scratch_dir)

    options: str = '\n'.join([
        "",
        "# Mesh options generated by press_common.generate_mesh",
        "mpm_voxel:",
        f"  filename: {voxel_data.resolve()}",
        f"  pixel_size: {DIE_PIXEL_SIZE}",
        "",
        "dm_plex:",
        f"  filename: {mesh_file.resolve()}",
        "  dim: 3",
        "  simplex: 0",
        "",
        "remap:",
        f"  direction: z",
        f"  scale: {(1 - load_fraction)} # (1 - load_fraction) to match displacement",
        "",
    ])
    if clamp_top:
        options += '\n'.join([
            "bc:",
            "  clamp: 1,2",
            "  # Clamped displacement for top and bottom",
            "  clamp_2:",
            f"    translate: 0,0,{-load_fraction * DIE_HEIGHT} # -load_fraction * height",
            "  # Prevent x,y expansion beyond the die boundary",
            "  slip: 3",
            "  slip_3:",
            "    components: 0,1",
            "",
        ])
    else:
        options += '\n'.join([
            "bc:",
            "  slip: 1,2,3",
            "  # Allow x,y displacement for top and bottom, prescribe z displacement",
            "  slip_1:",
            "    components: 2",
            "  slip_2:",
            "    components: 2",
            f"    translate: {-load_fraction * DIE_HEIGHT} # -load_fraction * height",
            "  slip_3:",
            "    components: 0,1",
            "",
        ])

    print(f"[info]Generated mesh options:[/]")
    syntax = Syntax(options, "yaml")
    print(syntax)

    return options


def generate_mesh(characteristic_length: float, voxel_data: Path, scratch_dir: Path) -> Path:
    mesh_dir = scratch_dir / "meshes"
    if not mesh_dir.exists():
        mesh_dir.mkdir(parents=True, exist_ok=True)
    if not voxel_data.exists():
        raise FileNotFoundError(f"Voxel data {voxel_data} does not exist")
    mesh_file = mesh_dir / f"cylinder_{voxel_data.stem}_CL{characteristic_length}.msh"
    if mesh_file.exists():
        console.print(f"[info]Using existing mesh [/]{mesh_file}")
        return mesh_file.resolve()

    element_order = 1
    center = DIE_CENTER
    radius = DIE_RADIUS
    height = DIE_HEIGHT

    layers = int(ceil(DIE_HEIGHT / characteristic_length))
    print(f"[info]Center: [/]{center}")
    print(f"[info]Radius: [/]{radius}")
    print(f"[info]Height: [/]{height}")
    print(f"[info]Number of layers: [/]{layers}")
    print(f"[info]Element order: [/]{element_order}")
    print(f"[info]Characteristic length: [/]{characteristic_length}")

    SURFACE = 2
    VOLUME = 3
    gmsh.initialize()

    # create cylinder mesh
    disk = gmsh.model.occ.addDisk(center[0], center[1], center[2], radius, radius)

    # Extrude the disk along (0, 0, height) with the specified number of layers.
    # The 'recombine=True' option tells gmsh to recombine triangular faces into quads.
    # The extrude function returns a list of new entities:
    #  - extruded[0]: the top surface,
    #  - extruded[1]: the volume,
    #  - extruded[2]: the lateral (side) surface.
    extruded = gmsh.model.occ.extrude([(SURFACE, disk)], 0, 0, height,
                                      numElements=[layers],
                                      recombine=True)

    # Extract tags from the extrusion result.
    top_surface = extruded[0][1]  # Top surface created by extrusion.
    volume = extruded[1][1]  # The volume.
    lateral_surface = extruded[2][1]  # The lateral surface.

    # Synchronize to update the model with the new entities.
    gmsh.model.occ.synchronize()

    # Force recombination of bottom surface
    gmsh.model.mesh.setRecombine(SURFACE, disk)

    # set mesh options
    gmsh.option.setNumber("General.NumThreads", cpu_count())
    gmsh.option.setNumber("Mesh.RecombinationAlgorithm", 3)
    gmsh.option.setNumber("Mesh.Algorithm", 8)
    gmsh.option.setNumber("Mesh.Algorithm3D", 10)
    gmsh.option.setNumber("Mesh.MeshSizeMin", 0.75)
    gmsh.option.setNumber("Mesh.MeshSizeMax", 1.0)
    gmsh.option.setNumber("Mesh.MeshSizeFactor", characteristic_length)
    gmsh.option.setNumber("Mesh.ElementOrder", element_order)
    gmsh.option.setNumber("Mesh.HighOrderOptimize", 1 if element_order > 1 else 0)

    # set physical groups
    gmsh.model.addPhysicalGroup(SURFACE, [disk], 1)
    gmsh.model.setPhysicalName(SURFACE, 1, "bottom")
    gmsh.model.addPhysicalGroup(SURFACE, [top_surface], 2)
    gmsh.model.setPhysicalName(SURFACE, 2, "top")
    gmsh.model.addPhysicalGroup(SURFACE, [lateral_surface], 3)
    gmsh.model.setPhysicalName(SURFACE, 3, "outside")
    gmsh.model.addPhysicalGroup(VOLUME, [volume], 1)
    gmsh.model.setPhysicalName(VOLUME, 1, "cylinder")

    # generate mesh
    gmsh.model.mesh.generate(3)

    # save mesh
    gmsh.write(str(mesh_file))
    gmsh.finalize()

    if not mesh_file.exists():
        raise RuntimeError(f"Failed to generate mesh file: {mesh_file}")

    print(f"[info]Mesh saved to [/]{mesh_file}")
    return mesh_file
